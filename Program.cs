using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Xml.Linq;

namespace XmlDocPrivatizer
{
	public sealed class Program
	{
		private static readonly Regex MemberRegex = new Regex(@"(?<=\.)\#?([\w`]+\(.+$|[\w`]+$)");
		private static readonly Regex ArgsRegex   = new Regex(@"(?<=[\(,{])[\w\.`\[\]]+(?=[\),{}])|(})");
		private static readonly Regex MethodRegex = new Regex(@"([_a-zA-Z][\w]+)((?=[\(`])|$)");
		private const BindingFlags PublicFlags = BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance;

		private static Assembly[] _referencesAssemblies;
		private static Assembly   _assembly;

		static void Main(string[] args)
		{
			if (args.Length == 0)
			{
				WriteHelp();
				return;
			}

			var arg0 = args[0];
			if (arg0 == "-h" || arg0 == "-help" || arg0 == "--help" || arg0 == "?")
			{
				WriteHelp();
				return;
			}

			if (arg0 == "-l" || arg0 == "--legacy")
			{
				LegacyProcessing(args);
				return;
			}

			AssemblyProcessing(args);
		}

		private static void WriteHelp()
		{
			Console.WriteLine(@"XmlDocPrivatizer is a tool that automates removing private types/members from .xml docs generated by Visual Studio.");
			Console.WriteLine("There are two modes. Both require path to .xml file and output at the end of arg list. \n * Legacy mode (opt-in via -l or --legacy) removes comment if it contains specified tag, by default it's <private/> tag");
			Console.WriteLine(@"-t or --tag to specify custom tag");
			Console.WriteLine(@" * Default mode needs additional assembly reference. Specify path to assembly after all options and before file paths.");
			Console.WriteLine();
			Console.ReadKey();
		}

		private static void LegacyProcessing(string[] args)
		{
			string privateTag = "private";
			int i = 1;
			if (args[1] == "-t" || args[1] == "--tag")
			{
				privateTag = args[2];
				Console.WriteLine($"private tag: {privateTag}");
				i = 3;
			}

			var inputPath = args[i];
			if (!File.Exists(inputPath))
			{
				Console.WriteLine($"invalid .xml path: {inputPath}!");
				return;
			}

			Process(inputPath, args[i+1], privateTag);
			Console.WriteLine("operation complete. exit now...");
			Console.ReadKey();
		}

		private static void Process(string inputPath, string outputPath, string tag)
		{
			XDocument document = XDocument.Load(inputPath);
			document.Descendants(tag).Select(n => n.Parent).Remove();
			document.Save(outputPath);
		}

		private static void AssemblyProcessing(string[] args)
		{
			var outputIndex = args.Length - 1;
			var assemblyPath = args[outputIndex - 2];
			if (!File.Exists(assemblyPath))
			{
				Console.WriteLine("Assembly not found at this path");
				return;
			}
			var inputPath = args[outputIndex - 1];
			if (!File.Exists(inputPath))
			{
				Console.WriteLine(".xml not found at this path");
				return;
			}

			_assembly = Assembly.LoadFrom(assemblyPath);
			var document = XDocument.Load(inputPath);
			ProcessMembers(document);
			document.Save(args[outputIndex] );
			Console.WriteLine("operation complete. exit now...");
			Console.ReadKey();
		}

		private static void ProcessMembers(XDocument document)
		{
			var members = document.Descendants("member");
			members.Where(x => Excluded(x)).Remove();
		}

		private static bool Excluded(XElement elem)
		{
			var name = elem.Attribute("name").Value;
			var memberType = name[0];
			name = name.Substring(2);
			if (name.Count(c => c == '#') > 1) // probably explicit interface implementation that is, let's assume that interface method has documentation
				return false;

			string typeName;
			if (memberType == 'T')
			{
				typeName = name;
				return ! TypePublic(typeName, out Type t);
			}
			var memberMatch = MemberRegex.Match(name);
			typeName = name.Substring(0, memberMatch.Index - 1);
			if (!TypePublic(typeName, out Type type))
				return true;

			return ExcludedMember(type, memberMatch.Value, memberType);
		}

		private static bool TypePublic(string typeName, out Type type)
		{
			type = FindType(typeName);
			if (type == null)
				return false;
			return type.IsPublic;
		}

		private static bool ExcludedMember(Type t, string memberString, char memberType)
		{
			switch (memberType)
			{
				case 'M':
					try
					{	// there's just too much things that may go wrong
						return MethodExluded(t, memberString);
					}
					catch (Exception)
					{
						return false;
					}
				case 'F': return t.GetField(memberString, PublicFlags) == null;
				case 'P': return !memberString.EndsWith(")") // item (indexer) property
									? t.GetProperty(memberString, PublicFlags) == null
									: IndexerExluded(t, memberString);
				default: return false;
			}
		}

		private static bool IndexerExluded(Type t, string method)
		{
			var args     = GetArgs(method);
			var indexers = t.GetProperties().Select(m => m.GetIndexParameters())
											.Where(p => p.Length > 0);
			return indexers.All(prms => ParametersWrong(prms, args));
		}

		private static bool MethodExluded(Type t, string method)
		{
			var args = GetArgs(method);
			if (method[0] == '#')
			{
				if (args.All(ar => ar != null))
					return t.GetConstructor(args) == null;

				var ctors = t.GetConstructors(PublicFlags);
				return ctors.Select(ctor => ctor.GetParameters()).All(prms => ParametersWrong(prms, args));
			}
			var mname = MethodRegex.Match(method).Value;
			var methods = t.GetMethods().Where(m => m.Name == mname);
			return methods.Select(m => m.GetParameters()).All(prms => ParametersWrong(prms, args));
		}

		private static bool ParametersWrong(ParameterInfo[] prms, Type[] args)
		{
			if (prms.Length == args.Length)
			{
				for (var index = 0; index < prms.Length; index++)
				{
					var param = prms[index];
					if (args[index] == null && !param.ParameterType.IsGenericMethodParameter)
						return true;
					if (args[index] != null && param.ParameterType != args[index])
						return true;
				}
				return false;
			}
			return true;
		}

		private static Type[] GetArgs(string method)
		{
			if(!method.EndsWith(")"))
				return new Type[0];

			var genericTypes = new Stack<string>();
			var nestedTypes = new Dictionary<int, List<Type>>(3) {{0, new List<Type>()}};
			int currentNesting = 0;
			foreach (var m in ArgsRegex.Matches(method).Cast<Match>())
			{
				var s = m.Value;
				if (method[m.Index + m.Length] == '{') // strangely enough, this is < for generic types
				{
					currentNesting++;
					var types = new List<Type>();
					if (nestedTypes.ContainsKey(currentNesting))
						nestedTypes[currentNesting] = types;
					else
						nestedTypes.Add(currentNesting, types);

					genericTypes.Push(s);
					continue;
				}
				if (s == "}")
				{
					var types = nestedTypes[currentNesting];
					currentNesting--;
					var genericType = $"{genericTypes.Pop()}`{types.Count}";
					//genericType += $"<{string.Join(',', Enumerable.Range(1, types.Count).Select(ti => "T" + ti))}>";
					var gtTemplate = FindType(genericType);

					var gt = gtTemplate?.MakeGenericType(types.ToArray());
					nestedTypes[currentNesting].Add(gt);
				}
				else
					nestedTypes[currentNesting].Add(FindType(s));
			}
			return nestedTypes[0].ToArray();
		}

		private static Type FindType(string type)
		{
			var t = _assembly.GetType(type);
			if (t != null)
				return t;

			if(_referencesAssemblies == null)
				_referencesAssemblies = _assembly.GetReferencedAssemblies().Select(an => Assembly.Load(an)).ToArray();
			foreach (var assembly in _referencesAssemblies)
			{
				t = assembly.GetType(type);
				if (t != null)
					return t;
			}
			return null;
		}
	}
}
